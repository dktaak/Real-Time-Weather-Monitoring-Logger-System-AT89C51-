C51 COMPILER V9.60.0.0   UART_DRIVER                                                       05/09/2021 21:06:45 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART_DRIVER
OBJECT MODULE PLACED IN .\Objects\uart_driver.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uart_driver.c OPTIMIZE(8,SPEED) BROWSE PRINT(.\Listings\uart_driver.lst)
                    - TABS(2) OBJECT(.\Objects\uart_driver.obj)

line level    source

   1          /*uart intialisation and transmission*/
   2          #include"header.h"
   3          
   4          //u8 dec_to_bcd(u8 x){
   5          //  u8 m,n;
   6          //  m=x/10;
   7          //  n=x%10;
   8          //  x=((m<<4)|n);
   9          //  return x;
  10          //}
  11          void uart_init(u16 baud)
  12          {
  13   1        SCON=0X50;
  14   1        TMOD|=0X20;
  15   1        switch(baud)
  16   1        {
  17   2        case 7200:TH1=252;break;
  18   2        case 9600:TH1=253;break;
  19   2        case 14400:TH1=254;break;
  20   2        case 28800:TH1=255;break;
  21   2        case 57600:
  22   2          TH1=255;PCON |=(1<<7);break;
  23   2        }
  24   1        TR1=1;
  25   1      }
  26          
  27          void uart_tx(u8 ch)
  28          {
  29   1      SBUF=ch;
  30   1      while(TI==0);
  31   1      TI=0;
  32   1      }
  33          
  34          //u8 uart_rx(void)
  35          //{
  36          //while(RI==0);
  37          //  RI=0;
  38          //return SBUF;
  39          //}
  40          
  41          void uart_tx_string(u8 *str)
  42          {
  43   1        while(*str)
  44   1        {
  45   2      //    if(*str>='0'&&*str<='9')
  46   2      //      uart_tx(*str48);
  47   2          //else
  48   2          uart_tx(*str);
  49   2          str++;
  50   2        }
  51   1      }
  52          
  53          //void uart_rx_string(u8 *ptr,u8 max_len)
  54          //{
C51 COMPILER V9.60.0.0   UART_DRIVER                                                       05/09/2021 21:06:45 PAGE 2   

  55          //  u8 i;RI=0;
  56          //  for(i=0;i<max_len;i++)
  57          //  {
  58          //    while(RI==0);
  59          //    RI=0;//imp
  60          //    ptr[i]=SBUF;
  61          //    uart_tx(ptr[i]);
  62          //    if(ptr[i]==Enter_key){
  63          //      ptr[i]='\0';
  64          //      break;
  65          //    }
  66          //  }
  67          //  ptr[i]='\0';
  68          //}
  69          u8 conv_int(s16 n,s8* a)
  70          {
  71   1        s8 i=0,k=0,j=0,temp=0;
  72   1      //static u8 a[10];
  73   1        if(n==0)
  74   1        {
  75   2          a[i]=48;
  76   2          ++i;
  77   2          goto l1;
  78   2        }
  79   1        if(n<0){
  80   2          n=-n;
  81   2          a[i++]='-';
  82   2          k++;
  83   2        }
  84   1        while(n)
  85   1        {
  86   2          a[i++]=(n%10)+48;
  87   2          n=n/10;
  88   2        }
  89   1        for(j=i-1;k<j;k++,j--)
  90   1        {
  91   2          temp=a[j];
  92   2          a[j]=a[k];
  93   2          a[k]=temp;
  94   2        } 
  95   1        l1:
  96   1        a[i]='\0';
  97   1        return i+1;
  98   1      }
  99          u8 conv_float(float f,u8* a){
 100   1        u8 ip,dp;u8 i=0;
 101   1        if(f<0){
 102   2          f=-f;
 103   2          a[i]='-';
 104   2        }
 105   1        ip=f;
 106   1        conv_int(ip,a);
 107   1        while(a[i++]);
 108   1        i--;
 109   1        a[i++]='.';
 110   1        dp=(f-ip)*100;
 111   1        conv_int(dp,a+i++);
 112   1        if(dp%10==0)
 113   1        {
 114   2          a[i++]=48;
 115   2          a[i]='\0';
 116   2        }
C51 COMPILER V9.60.0.0   UART_DRIVER                                                       05/09/2021 21:06:45 PAGE 3   

 117   1        return i+1;
 118   1      }
 119          
 120          
 121          //void uart_int(s16 n)
 122          //{
 123          //  s8 i=0,a[10];
 124          //  if(n<0){
 125          //    uart_tx('-');
 126          //    n=-n;
 127          //  }
 128          //  if(n==0)
 129          //    uart_tx(48);
 130          //  while(n)
 131          //  {
 132          //    a[i]=(n%10)+48;
 133          //    n=n/10;
 134          //    i++;
 135          //  }
 136          //  for(--i;i>=0;i--)
 137          //  {
 138          //    uart_tx(a[i]);
 139          //  } 
 140          //}
 141          //void uart_float(float f){
 142          //  long int ip,dp;
 143          //  if(f<0){
 144          //    uart_tx('-');
 145          //    f=-f;
 146          //  }
 147          //  ip=f;
 148          //  dp=(f-ip)*100;
 149          //  uart_int(ip);
 150          //  uart_tx('.');
 151          //  uart_int(dp);
 152          //  if(dp==0)
 153          //  uart_tx(48);
 154          //}
 155          //void uart_tx_integer(u8 n)
 156          //{
 157          //  s8 i=0,j,a[3]={0,0,0};
 158          //  while(n)
 159          //  {
 160          //    a[i]=(n%10)+48;
 161          //    n=n/10;
 162          //    i++;
 163          //  }
 164          //  for(j=i-1;j>=0;j--)
 165          //  {
 166          //    uart_tx(a[j]);
 167          //  } 
 168          //}
 169          //void uart_rx_time(u8 *d)
 170          //{
 171          //uart_rx_string(d,10);
 172          
 173          //d[0]=(((d[0]%48)<<4)|(d[1]%48));
 174          //d[1]=(((d[3]%48)<<4)|(d[4]%48));
 175          //d[2]=(((d[6]%48)<<4)|(d[7]%48));
 176          
 177          //  if(d[9]=='A')
 178          //    d[3]=0;
C51 COMPILER V9.60.0.0   UART_DRIVER                                                       05/09/2021 21:06:45 PAGE 4   

 179          //  else
 180          //    d[3]=1;
 181          //  
 182          //   d[4]='\0';
 183          //}
 184          
 185          //void uart_rx_date(u8 *d)
 186          //{
 187          //uart_rx_string(d,8);
 188          
 189          //d[0]=(((d[0]%48)<<4)|(d[1]%48));
 190          //d[1]=(((d[3]%48)<<4)|(d[4]%48));
 191          //d[2]=(((d[6]%48)<<4)|(d[7]%48));
 192          //   
 193          //   d[4]='\0';
 194          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    583    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
